---
sidebar_position: 3
---

# Основи Ink

Ink - це спеціалізована мова для створення інтерактивних сценаріїв, яка має багатий інструментарій для роботи з текстом. Сценарій Ink містить текст та варіанти вибору, які можуть розгалужувати сюжет.

Атрамент використовує Ink для опису сценарію гри та керування її виглядом.

:::tip
Назви змінних, констант, функцій, вузлів та стібків можуть бути українською:
```c
VAR монети = 0
-> початок

=== function змінити_кількість_монет(кількість)
  ~ монети = монети + кількість

=== початок
У вас є {монети} монет.
Зробіть вибір:
+ [Отримати 1 монету]
    Ви отримали монету.
    ~ змінити_кількість_монет(1) 
    -> початок
+ {монети > 0} [Витратити 1 монету]
    Ви витратили монету.
    ~ змінити_кількість_монет(-1)
    -> початок
```
:::

## Текст та вибори

```c
// це коментарій
Це абзац тексту.
* Вибір 1
    // вибори із символом "*" зникнуть, коли гравець знову перейде на цей параграф
    Ви обрали перший варіант.
+ Вибір 2
    // вибори з символом "+" завжди присутні
    Ви обрали другий варіант.
- // це точка збору (gather), текст продовжується з цього моменту
Історія продовжується.

// Оператор клею, "<>", "зклеює" декілька рядків в один
This text
<> is displayed
<> as a single line.

// це означає кінець сценарію
-> END
```

Ink відображає текст обраного варіанту вибору у наступному параграфі. Щоб уникнути цього, використовуйте такий синтаксис:
```
+ [Вибір 1]
```

## Вузли та стібки

**Вузли** (knots) - це іменовані розділи вашого сценарію. Ви можете посилатися на них у переходах (diverts) та умовах. **Стібки** (stitches) - це іменовані фрагменти всередині вузлів. У вузлі ви можете посилатися на них по імені, але маєте використовувати повне ім'я, щоб посилатися на них з інших вузлів.

```c
// Це перехід на вузол - він потрібен, бо Ink не переходить у вузол самостійно.
-> knot_1

=== knot_1
Текстовий вміст першого вузла.
+ [Вибір 1] -> stitch_1
+ [Вибір 2] -> stitch_2

= stitch_1
Ви обрали перший варіант.
-> knot_2.stitch_2 // перехід на стібок в іншому вузлі

= stitch_2
Ви обрали другий варіант.
-> knot_2 // перехід на вузол

=== knot_2
Текстовий вміст другого вузла.
-> stitch_1 // перехід на стібок в цьому вузлі

= stitch_1
Перший стібок другого вузла.
-> END

= stitch_2
Другий стібок другого вузла.
-> END
```

## Змінні та константи

```c
// визначення глобальної змінної
VAR city_name = "Київ"

// вивід змінної в тексті
Вас вітає місто {city_name}!

// зміна значення
~ city_name = "Лондон"

// визначення тимчасової змінної: вона існує тільки всередині
// вузла/стібка і знищується при виході з нього
=== city_kyiv
~ temp main_street = "Хрещатик"
Ви знаходитеся на вулиці {main_street}.
```

Константи використовуються так само, як і змінні, але їхнє значення не може бути змінено.

```c
// визначення константи
CONST GOLD_COIN_VALUE = 100

// використання константи в грі
Цей меч коштує {5 * GOLD_COIN_VALUE} монет.
```

## Математика

Ink підтримує чотири основні математичні дії (`+`, `-`, `*` та `/`), а також `%` (або `mod`), який повертає залишок після цілочисельного ділення. 

Також є декілька математичних функцій:

| Функція | Опис |
| :------ | :---------- |
| `RANDOM(min, max)` | Випадкове число між мінімумом і максимумом (включно з обома). `RANDOM(1,6)` повертає одне з цих чисел випадково: 1,2,3,5,6. |
| `POW(x, y)` | `x` в ступені `y`. `POW(3,2)` поверне 9. |
| `INT(x)` | Округлення до найближчого цілого числа. `INT(4.12)` поверне 4. |
| `FLOOR(x)` | Округлення до найбільшого цілого числа. `FLOOR(4.12)` поверне 5. |

## Умови

Ви можете використовувати умови для зміни тексту і варіантів вибору. Умови можуть включати в себе змінні та імена вузлів та стібків (це булеві змінні, які мають значення `true` після відвідування).

### Умовний текст

```
// показати текст, якщо змінна "know_real_name" має істинне значення
{know_real_name:Я знаю його справжнє ім'я.}

// показати різний текст в залежності, чи має змінна "know_real_name" істинне значення
Його справжне ім'я - {know_real_name:Пітер Паркер|таємниця}.

// складна умова в залежності від значення змінної "hero"
Ім'я цього героя - {
    - hero == "Людина-павук":
        <>Пітер Паркер
    - hero == "Залізна людина":
        <>Тоні Старк
    - else:
        <>це таємниця
}<>.
```

### Умовні вибори

Щоб показувати чи ховати варіанти вибору, ви можете вказати умову перед текстом вибору:

```c
VAR weapon = "sword"
-> story
=== story
{
    - weapon == "sword":
        Ви тримаєте меч.
    - weapon == "rifle":
        Ви тримаєте рушницю.
    - else:
        Ви неозброєні.
}
// Вибори відображаються в залежності від
// значення змінної "weapon"
+ {weapon == "sword"} [Рубати мечем]
    Ви замахуєтеся мечем.
    -> story
+ {weapon == "rifle"} [Стріляти з рушниці]
    Ви цілитеся та стріляєте.
    -> story
+ {weapon != "sword"} [Взяти меч]
    ~ weapon = "sword"
    -> story
+ {weapon != "rifle"} [Взяти рушницю]
    ~ weapon = "rifle"
    -> story
+ {weapon} [Прибрати зброю] // показати цей вибір якщо змінна "weapon" не пуста
    ~ weapon = ""
    -> story
```

Назви вузлів та стібків є булевими змінними, які стають істинними після відвідування, тож ви можете цим скористатися:

```c
* { not visit_kyiv } [Відвідати Київ вперше] -> visit_kyiv
+ { visit_kyiv }     [Повернутися до Києва] -> visit_kyiv

=== visit_kyiv
...
```

Ви можете використовувати складні умови з оператором "ТА" (`&&`, `and`) і "АБО" (`||`, `or`):

```c
* { not (visit_kyiv or visit_rome) && (visit_london || visit_new_york) } [ Подорожувати ] -> visit_someplace
```

## Функції

Функції - це іменовані вузли з спеціальним синтаксисом. Вони можуть приймати аргументи, повертати значення і відображати текст.

```c
VAR coins = 0
-> story

=== function coins_change(amount)
  // ця функція змінює значення
  ~ coins = coins + amount

=== function show_coins()
   // ця функція відображає текст
   You have {coins} coins.

=== function buy_a_sword()
    // ця функція повертає текст, який пізніше можна використати
    { coins < 5:
        ~ return "На жаль, ви не можете дозволити собі меч"
    - else:
        ~ coins = coins - 5
        ~ return "Ви придбали меч"
    }

=== story
// Функція show_coins function відображає текст,
// тому під час її виклику він буде показаний
~ show_coins()
Зробіть вибір:
+ [Отримати 1 монету]
    Ви отримали монету.
    ~ coins_change(1) // змінити значення змінної "coins"
    -> story
+ {coins > 0} [Витратити 1 монету]
    Ви витратили монету.
    ~ coins_change(-1) // змінити значення змінної "coins"
    -> story
+ [Купити меч (5 монет)]
    // Функція buy_a_sword повертає значення, тож ми можемо
    // записати його в змінну і використати далі
    ~ temp output = buy_a_sword() 
    Ви відвідуєте коваля. {output}.
    -> story
```

## Теги

Теги в Ink можуть надавати інструкції для застосунку, який відтворює сценарій.

```c title="story.ink"
// глобальні теги визначаються в самому початку
// головного файлу Ink
# title: Мій твір
# author: Автор-початківець
VAR current_music = "silence"

-> main
=== main
// тег параграфу застосовується до наступного абзацу
# IMAGE: illustration.jpg
Тут починається вашв історія.

// значення тегів можуть бути змінені в скрипті
~ current_music = "story1"
# MUSIC: {current_music}.mp3
Що ви оберете?

+ Завершити історію #UNCLICKABLE // тег вибору застосовується до вибору та контенту після нього
    Кінець історії.
    -> END
+ [Вибір 1 #UNCLICKABLE] // тег вибору, застосовується лише до самого вибору
    Інший кінець історії.
    -> END
+ [Вибір 2 #{has_rifle:UNCLICKABLE}] // умовний тег вибору, встановлюється лише якщо "has_rifle" є істинною
    Знову кінець історії.
    -> END
+ [Вибір 3]
    # IMAGE: paragraph3.jpg // тег параграфу застосовується до тексту після вибору
    Фінал.
    -> END
```

## Декілька Ink-файлів

Якщо ваш сценарій стає занадто великим, ви можете розділити його на декілька файлів. Один з них стає головним файлом сценарію і має містити оператори `INCLUDE`. Під час компіляції сценарію Ink ці оператори `INCLUDE` заміняються контентом файлів, вказаних як їхні параметри.

:::warning
Оператори INCLUDE мають бути в самому початку файлу, відразу після глобальних тегів.
:::

```c title="story.ink"
// це головний файл сценарію
# title: Моя історія
# author: Автор-початківець
INCLUDE story1.ink
INCLUDE story2.ink

-> main
=== main
Історія починається тут.
+ [Вибір 1] -> story_knot_1
+ [Вибір 2] -> story_knot_2

=== story_end
Історія завершена.
-> END
```

```c title="story1.ink"
=== story_knot_1
Текст першого вузла.
+ [OK] -> story_end
```

```c title="story2.ink"
=== story_knot_2
Текст другого вузла.
+ [OK] -> story_end
```

## Інші можливості

Ink має багато інших можливостей: умовний контент, потоки, списки тощо. Зверніться до офіціальної документації по Ink, "[Writing with Ink](https://github.com/inkle/ink/blob/master/Documentation/WritingWithInk.md)", щоб дізнатися про них.

## Документація

* [Writing web-based interactive fiction with Ink](https://www.inklestudios.com/ink/web-tutorial/) - короткий посібник по основах Ink
* [Writing with Ink](https://github.com/inkle/ink/blob/master/Documentation/WritingWithInk.md) - основна документація по мові Ink
* [Running your Ink](https://github.com/inkle/ink/blob/master/Documentation/RunningYourInk.md) - інтеграція Ink з ігровим рушієм. Також описує синтаксис тегів.
